# GitLab CI/CD Pipeline for dman dotfile sync tool
# Target: Ubuntu Linux with Docker executor
# Go version: 1.24

image: registry.tyss.io/cj3636/ci-images/go1.24:latest

# Define pipeline stages
stages:
  - validate
  - test
  - build
  - security
  - package
  - deploy

# Global variables
variables:
  GO_VERSION: "1.24"
  CGO_ENABLED: "0"
  GOOS: "linux"
  GOARCH: "amd64"
  COVERAGE_THRESHOLD: "70"

# Cache Go modules for faster builds
cache:
  key: "${CI_JOB_NAME}"
  paths:
    - .cache/go-build/
    - go.sum
  policy: pull-push

# Before script to set up Go environment
before_script:
  - export GOPATH="$CI_PROJECT_DIR/.cache/go"
  - export GOCACHE="$CI_PROJECT_DIR/.cache/go-build"
  - export PATH="$GOPATH/bin:$PATH"
  - mkdir -p "$GOPATH" "$GOCACHE"
  - go version
  - go mod download

# =============================================================================
# VALIDATION STAGE
# =============================================================================

format:
  stage: validate
  script:
    - echo "Checking Go code formatting..."
    - gofmt -l . | tee format-issues.txt
    - |
      if [ -s format-issues.txt ]; then
        echo "❌ Code formatting issues found:"
        cat format-issues.txt
        echo "Run 'go fmt ./...' to fix formatting issues"
        exit 1
      fi
    - echo "✅ Code formatting is correct"
  artifacts:
    reports:
      junit: format-issues.txt
    when: on_failure
    expire_in: 1 day
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

vet:
  stage: validate
  script:
    - echo "Running go vet static analysis..."
    - go vet ./...
    - echo "✅ Static analysis passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

lint:
  stage: validate
  script:
    - echo "Installing staticcheck..."
    - go install honnef.co/go/tools/cmd/staticcheck@latest
    - echo "Running staticcheck linter..."
    - staticcheck ./...
    - echo "✅ Linting passed"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

mod:
  stage: validate
  script:
    - echo "Verifying Go modules..."
    - go mod verify
    - go mod tidy
    - |
      if ! git diff --quiet go.mod go.sum; then
        echo "❌ go.mod or go.sum is not up to date"
        echo "Run 'go mod tidy' and commit the changes"
        git diff go.mod go.sum
        exit 1
      fi
    - echo "✅ Go modules are valid and up to date"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# TEST STAGE
# =============================================================================

unit:
  stage: test
  script:
    - echo "Running unit tests..."
    - go test -v -race ./...
    - echo "✅ Unit tests passed"
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

coverage:
  stage: test
  script:
    - echo "Running tests with coverage..."
    - go test -race -coverprofile=coverage.out -covermode=atomic ./...
    - go tool cover -func=coverage.out | tee coverage.txt
    - go tool cover -html=coverage.out -o coverage.html
    - |
      total=$(go tool cover -func=coverage.out | grep total: | awk '{gsub(/%/,"",$$3); split($$3,a,"."); print a[1]}')
      threshold=$COVERAGE_THRESHOLD
      echo "Coverage: ${total}%"
      if [ "$total" -lt "$threshold" ]; then
        echo "❌ Coverage $total% below threshold $threshold%"
        exit 1
      else
        echo "✅ Coverage $total% meets threshold $threshold%"
      fi
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.out
      - coverage.html
      - coverage.txt
    expire_in: 30 days
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

race:
  stage: test
  script:
    - echo "Running race condition tests..."
    - go test -race -count=5 ./internal/server/
    - go test -race -count=5 ./internal/storage/
    - echo "✅ Race condition tests passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

benchmark:
  stage: test
  script:
    - echo "Running benchmark tests..."
    - go test -bench=. -benchmem ./internal/storage/ | tee benchmark.txt
    - echo "✅ Benchmark tests completed"
  artifacts:
    paths:
      - benchmark.txt
    expire_in: 7 days
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# BUILD STAGE
# =============================================================================

build:
  stage: build
  variables:
    # Generate version info from git
    VERSION: ${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
    COMMIT: ${CI_COMMIT_SHORT_SHA}
    BUILD_TIME: $(date -u +%Y-%m-%dT%H:%M:%SZ)
  script:
    - echo "Building dman application..."
    - echo "Version:${VERSION}"
    - echo "Commit:${COMMIT}" 
    - echo "Build Time:$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    - |
      LDFLAGS="-X git.tyss.io/cj3636/dman/internal/buildinfo.Version=$VERSION \
               -X git.tyss.io/cj3636/dman/internal/buildinfo.Commit=$COMMIT \
               -X git.tyss.io/cj3636/dman/internal/buildinfo.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    - mkdir -p bin/
    - go build -ldflags "$LDFLAGS" -o bin/dman ./cmd/dman
    - chmod +x bin/dman
    - ./bin/dman version
    - echo "✅ Build completed successfully"
  artifacts:
    paths:
      - bin/dman
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

build-multi-arch:
  stage: build
  variables:
    VERSION: ${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
    COMMIT: ${CI_COMMIT_SHORT_SHA}
  script:
    - echo "Building multi-architecture binaries..."
    - mkdir -p dist/
    - |
      LDFLAGS="-X git.tyss.io/cj3636/dman/internal/buildinfo.Version=$VERSION \
               -X git.tyss.io/cj3636/dman/internal/buildinfo.Commit=$COMMIT \
               -X git.tyss.io/cj3636/dman/internal/buildinfo.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    - |
      # Build for multiple platforms
      for GOOS in linux darwin windows; do
        for GOARCH in amd64 arm64; do
          if [ "$GOOS" = "windows" ]; then
            EXT=".exe"
          else
            EXT=""
          fi
          echo "Building for $GOOS/$GOARCH..."
          env GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "$LDFLAGS" \
            -o "dist/dman-$GOOS-$GOARCH$EXT" ./cmd/dman
        done
      done
    - ls -la dist/
    - echo "✅ Multi-architecture build completed"
  artifacts:
    paths:
      - dist/
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# SECURITY STAGE
# =============================================================================

security:
  stage: security
  script:
    - echo "Installing gosec security scanner..."
    - go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
    - echo "Running security scan..."
    - gosec -fmt json -out gosec-report.json ./...
    - gosec ./...
    - echo "✅ Security scan completed"
  artifacts:
    reports:
      sast: gosec-report.json
    paths:
      - gosec-report.json
    expire_in: 30 days
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

dependency:
  stage: security
  script:
    - echo "Installing govulncheck..."
    - go install golang.org/x/vuln/cmd/govulncheck@latest
    - echo "Scanning for known vulnerabilities..."
    - govulncheck ./...
    - echo "✅ Vulnerability scan completed"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# PACKAGE STAGE
# =============================================================================

docker:
  stage: package
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    IMAGE_TAG: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
    LATEST_TAG: ${CI_REGISTRY_IMAGE}:latest
  before_script:
    - docker info
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - |
      cat > Dockerfile << 'EOF'
      FROM alpine:3.19
      RUN apk --no-cache add ca-certificates tzdata
      WORKDIR /app
      COPY bin/dman /usr/local/bin/dman
      RUN chmod +x /usr/local/bin/dman
      EXPOSE 3626
      USER 1000:1000
      ENTRYPOINT ["/usr/local/bin/dman"]
      CMD ["serve", "--addr", ":3626"]
      EOF
    - docker build -t $IMAGE_TAG -t $LATEST_TAG .
    - docker push $IMAGE_TAG
    - |
      if [ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ] || [ -n "$CI_COMMIT_TAG" ]; then
        docker push $LATEST_TAG
      fi
    - echo "✅ Docker image built and pushed"
  dependencies:
    - build
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

release:
  stage: package
  script:
    - echo "Creating release archives..."
    - mkdir -p release/
    - |
      cd dist/
      for file in dman-*; do
        if [[ $file == *"windows"* ]]; then
          zip "../release/${file}.zip" "$file"
        else
          tar -czf "../release/${file}.tar.gz" "$file"
        fi
      done
    - ls -la release/
    - echo "✅ Release archives created"
  artifacts:
    paths:
      - release/
    expire_in: 1 year
  dependencies:
    - build-multi-arch
  rules:
    - if: $CI_COMMIT_TAG

# =============================================================================
# DEPLOY STAGE
# =============================================================================

staging:
  stage: deploy
  environment:
    name: staging
    url: https://dman-staging.tyss.io
  script:
    - echo "Deploying to staging environment..."
    - echo "Docker image:${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}"
    # Add your deployment logic here (e.g., kubectl, docker-compose, etc.)
    - echo "✅ Deployed to staging"
  dependencies:
    - docker
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: manual

production:
  stage: deploy
  environment:
    name: production
    url: https://dman.tyss.io
  script:
    - echo "Deploying to production environment..."
    - echo "Docker image:${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"
    # Add your production deployment logic here
    - echo "✅ Deployed to production"
  dependencies:
    - docker
    - release
  rules:
    - if: $CI_COMMIT_TAG
  when: manual

# =============================================================================
# NOTIFICATION JOBS
# =============================================================================

notify-success:
  stage: .post
  script:
    - echo "✅ Pipeline completed successfully!"
    - echo "Commit:${CI_COMMIT_SHORT_SHA}"
    - echo "Branch:${CI_COMMIT_REF_NAME}"
    - echo "Pipeline URL:${CI_PIPELINE_URL}"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_COMMIT_TAG
      when: on_success

notify-failure:
  stage: .post
  script:
    - echo "❌ Pipeline failed!"
    - echo "Commit:${CI_COMMIT_SHORT_SHA}"
    - echo "Branch:${CI_COMMIT_REF_NAME}"
    - echo "Pipeline URL:${CI_PIPELINE_URL}"
    - echo "Please check the failed jobs and fix the issues."
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_failure
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_failure
    - if: $CI_COMMIT_TAG
      when: on_failure